import re
import json
import logging
import sys
import os
from strands import Agent, tool
from botocore.config import Config
from strands.models import BedrockModel
from typing import Dict, Any, List, Optional

# Add the app directory to path to import the correct AddressResult
sys.path.append(os.path.join(os.path.dirname(__file__), '../app'))
from models.response import AddressResult

# Set up logging for the agent
logger = logging.getLogger(__name__)

boto_config = Config(
    retries={"max_attempts": 3, "mode": "standard"},
    connect_timeout=5,
    read_timeout=1000
)

claude_model = BedrockModel(
    model_id="us.anthropic.claude-sonnet-4-20250514-v1:0",
    config=boto_config
)

@tool
def validate_korean_address_format(extracted_text: str) -> Dict[str, Any]:
    """
    Validate if extracted text follows Korean address format and identify components.
    
    Args:
        extracted_text (str): The text extracted from the image
        
    Returns:
        Dict: Validation results with component identification
    """
    # Korean address format patterns
    patterns = {
        "sido": r'(ÏÑúÏö∏ÌäπÎ≥ÑÏãú|Î∂ÄÏÇ∞Í¥ëÏó≠Ïãú|ÎåÄÍµ¨Í¥ëÏó≠Ïãú|Ïù∏Ï≤úÍ¥ëÏó≠Ïãú|Í¥ëÏ£ºÍ¥ëÏó≠Ïãú|ÎåÄÏ†ÑÍ¥ëÏó≠Ïãú|Ïö∏ÏÇ∞Í¥ëÏó≠Ïãú|ÏÑ∏Ï¢ÖÌäπÎ≥ÑÏûêÏπòÏãú|Í≤ΩÍ∏∞ÎèÑ|Í∞ïÏõêÌäπÎ≥ÑÏûêÏπòÎèÑ|Ï∂©Ï≤≠Î∂ÅÎèÑ|Ï∂©Ï≤≠ÎÇ®ÎèÑ|Ï†ÑÎ∂ÅÌäπÎ≥ÑÏûêÏπòÎèÑ|Ï†ÑÎùºÎÇ®ÎèÑ|Í≤ΩÏÉÅÎ∂ÅÎèÑ|Í≤ΩÏÉÅÎÇ®ÎèÑ|Ï†úÏ£ºÌäπÎ≥ÑÏûêÏπòÎèÑ)',
        "sigungu": r'([Í∞Ä-Ìû£]+Íµ¨|[Í∞Ä-Ìû£]+Ïãú|[Í∞Ä-Ìû£]+Íµ∞)',
        "road_name": r'([Í∞Ä-Ìû£]+Î°ú\s*\d*Í∏∏?|[Í∞Ä-Ìû£]+Í∏∏)',
        "building_number": r'(\d+(?:-\d+)?)',
        "dong": r'(\d+Îèô)',
        "ho": r'(\d+Ìò∏)',
        "legal_dong": r'\(([Í∞Ä-Ìû£]+Îèô)',
        "building_name": r'([Í∞Ä-Ìû£]+ÏïÑÌååÌä∏|[Í∞Ä-Ìû£]+ÎπåÎî©|[Í∞Ä-Ìû£]+ÌÉÄÏõå|[Í∞Ä-Ìû£]+Îß®ÏÖò)'
    }
    
    results = {}
    for component, pattern in patterns.items():
        match = re.search(pattern, extracted_text)
        results[component] = {
            "found": bool(match),
            "value": match.group(1) if match else None,
            "confidence": 0.9 if match else 0.1
        }
    
    return results


@tool
def lookup_address_components(sido: Optional[str] = None, sigungu: Optional[str] = None, road_name: Optional[str] = None, building_number: Optional[str] = None) -> Dict[str, Any]:
    """
    Lookup and validate address components using a mock database of known Korean addresses.
    This tool helps correct OCR errors and standardize address formats.
    
    Args:
        sido (Optional[str]): The province/city name (e.g., "ÏÑúÏö∏ÌäπÎ≥ÑÏãú")
        sigungu (Optional[str]): The district name (e.g., "Í∞ïÎÇ®Íµ¨")
        road_name (Optional[str]): The road name (e.g., "ÌÖåÌó§ÎûÄÎ°ú")
        building_number (Optional[str]): The building number (e.g., "123")

    Returns:
        Dict: Validated and corrected address components with suggestions
    """
    
    # Mock database of Korean addresses with corrections
    address_database = {
        "ÏÑúÏö∏ÌäπÎ≥ÑÏãú": {
            "standardized_name": "ÏÑúÏö∏ÌäπÎ≥ÑÏãú",
            "aliases": ["ÏÑúÏö∏Ïãú", "ÏÑúÏö∏"],
            "districts": {
                "Í∞ïÎÇ®Íµ¨": {
                    "standardized_name": "Í∞ïÎÇ®Íµ¨",
                    "aliases": ["Í∞ïÎÇ®"],
                    "roads": {
                        "ÌÖåÌó§ÎûÄÎ°ú": {"standardized_name": "ÌÖåÌó§ÎûÄÎ°ú", "aliases": ["ÌÖåÌó§ÎûÄ", "ÌÖåÌó§ÎûÄÍ∏∏"]},
                        "Í∞ïÎÇ®ÎåÄÎ°ú": {"standardized_name": "Í∞ïÎÇ®ÎåÄÎ°ú", "aliases": ["Í∞ïÎÇ®Î°ú"]},
                        "ÎÖºÌòÑÎ°ú": {"standardized_name": "ÎÖºÌòÑÎ°ú", "aliases": ["ÎÖºÌòÑÍ∏∏"]},
                        "Ïñ∏Ï£ºÎ°ú": {"standardized_name": "Ïñ∏Ï£ºÎ°ú", "aliases": ["Ïñ∏Ï£ºÍ∏∏"]},
                        "ÏûêÍ≥°Î°ú": {"standardized_name": "ÏûêÍ≥°Î°ú", "aliases": ["ÏûêÍ≥°Í∏∏"]},
                        "ÏïïÍµ¨Ï†ïÎ°ú": {"standardized_name": "ÏïïÍµ¨Ï†ïÎ°ú", "aliases": ["ÏïïÍµ¨Ï†ïÍ∏∏"]},
                        "ÎèÑÏÇ∞ÎåÄÎ°ú": {"standardized_name": "ÎèÑÏÇ∞ÎåÄÎ°ú", "aliases": ["ÎèÑÏÇ∞Í∏∏"]},
                        "ÌïôÎèôÎ°ú": {"standardized_name": "ÌïôÎèôÎ°ú", "aliases": ["ÌïôÎèôÍ∏∏"]},
                        "Î¥âÏùÄÏÇ¨Î°ú": {"standardized_name": "Î¥âÏùÄÏÇ¨Î°ú", "aliases": ["Î¥âÏùÄÏÇ¨Í∏∏"]},
                        "ÌóåÎ¶âÎ°ú": {"standardized_name": "ÌóåÎ¶âÎ°ú", "aliases": ["ÌóåÎ¶âÍ∏∏"]},
                        "ÏùºÏõêÎ°ú": {"standardized_name": "ÏùºÏõêÎ°ú", "aliases": ["ÏùºÏõêÍ∏∏"]},
                        "Î∞§Í≥†Í∞úÎ°ú": {"standardized_name": "Î∞§Í≥†Í∞úÎ°ú", "aliases": ["Î∞§Í≥†Í∞úÍ∏∏"]},
                        "ÎÇ®Î∂ÄÏàúÌôòÎ°ú": {"standardized_name": "ÎÇ®Î∂ÄÏàúÌôòÎ°ú", "aliases": ["ÎÇ®Î∂ÄÏàúÌôòÍ∏∏"]},
                        "Í∞úÌè¨Î°ú": {"standardized_name": "Í∞úÌè¨Î°ú", "aliases": ["Í∞úÌè¨Í∏∏"]},
                        "ÏñëÏû¨ÎåÄÎ°ú": {"standardized_name": "ÏñëÏû¨ÎåÄÎ°ú", "aliases": ["ÏñëÏû¨Í∏∏"]},
                        "Í¥ëÌèâÎ°ú": {"standardized_name": "Í¥ëÌèâÎ°ú", "aliases": ["Í¥ëÌèâÍ∏∏"]},
                        "ÏûêÍ≥°Î°ú": {"standardized_name": "ÏûêÍ≥°Î°ú", "aliases": ["ÏûêÍ≥°Í∏∏"]},
                        "ÏïïÍµ¨Ï†ïÎ°ú": {"standardized_name": "ÏïïÍµ¨Ï†ïÎ°ú", "aliases": ["ÏïïÍµ¨Ï†ïÍ∏∏"]},
                        "ÎèÑÏÇ∞ÎåÄÎ°ú": {"standardized_name": "ÎèÑÏÇ∞ÎåÄÎ°ú", "aliases": ["ÎèÑÏÇ∞Í∏∏"]},
                    }
                }
            }
        }
    }
    
    return address_database
    

# Create the Korean Address Confidence Analysis agent
korean_address_agent = Agent(
    model=claude_model,
    tools=[validate_korean_address_format, lookup_address_components],
    system_prompt="""You are a specialized AI agent for analyzing and correcting Korean address extraction from OCR results.

Your role is to:
1. Validate if extracted text follows Korean address format patterns
2. Analyze the quality of the extracted text
3. Use the lookup_address_components tool to validate and correct address components against a database
4. Calculate confidence scores for each address component
5. Return a structured AddressResult with standardized, corrected address components

When processing Korean addresses:
- Standard format: Ïãú¬∑ÎèÑ + Ïãú¬∑Íµ∞¬∑Íµ¨ + ÎèÑÎ°úÎ™Ö + Í±¥Î¨ºÎ≤àÌò∏ [Îèô] [Ìò∏Ïàò] (Î≤ïÏ†ïÎèôÎ™Ö, Í±¥Î¨ºÎ™Ö)
- Required components: sido (Ïãú¬∑ÎèÑ), sigungu (Ïãú¬∑Íµ∞¬∑Íµ¨), road_name (ÎèÑÎ°úÎ™Ö), building_number (Í±¥Î¨ºÎ≤àÌò∏)
- Optional components: dong (Îèô), ho (Ìò∏), legal_dong (Î≤ïÏ†ïÎèô), building_name (Í±¥Î¨ºÎ™Ö)

Process workflow:
1. First validate the address format and extract components
2. Use lookup_address_components to check and standardize sido, sigungu, and road_name component against the database
3. Apply any corrections suggested by the database lookup
4. Calculate final confidence scores considering database validation
5. If results are validated by the database, the confidence score is 1.0
6. If you make any changes that cannot be validated by the database, the confidence score must be lower than 0.3 which will be flagged for human review.
7. Return the corrected and standardized address components

Confidence score examples:
ÏûêÍ∑πÎ°ú -> ÏûêÍ≥°Î°ú (If validated by the database, the confidence score is 1.0)
20Ïù¥Îèô -> 20Îèô (Changes are not validated by the database hence maximum confidence score is 0.3)

Required human review:
- If the confidence score is lower than 0.3 for any component
- If sigungu, road_name is not validated by the database
- If there is only one of dong, ho. (e.g. 303Ìò∏ found only but no dong or 209Îèô found only but no ho)

Always use all provided tools to perform thorough analysis and correction."""
)

def extract_and_correct_korean_address(extracted_text: str) -> AddressResult:
    """
    Extract and correct Korean address using Strands agent with structured output.
    
    Args:
        extracted_text (str): Text extracted from OCR
        
    Returns:
        AddressResult: Structured and corrected address components
    """
    logger.info(f"ü§ñ [AGENT] Starting Korean address extraction and correction")
    logger.debug(f"üìù [AGENT] Input text: '{extracted_text}'")
    
    try:
        prompt = f"""
        Please analyze and correct this Korean address extracted from OCR: "{extracted_text}"
        
        Follow these steps:
        1. Use validate_korean_address_format to identify address components
        2. Use lookup_address_components to validate and correct each component against the database
        3. Apply any corrections suggested by the database lookup
        4. Return the standardized address components with confidence score for each component

        
        The response should contain the corrected and standardized address components.
        """

        structured_output_prompt = """The confidence field should be a dictionary of each address component with a confidence score between 0 and 1
        Example: {'sido': 1.0, 'sigungu': 1.0, 'road_name': 1.0, 'building_number': 1.0, 'dong': 1.0, 'ho': 1.0, 'legal_dong': 0.0, 'building_name': 0.0}"""
        
        logger.info(f"üîÑ [AGENT] Invoking Strands agent with structured output")
        # Use structured_output to get AddressResult
        agent_results = korean_address_agent(prompt)
        result = korean_address_agent.structured_output(AddressResult)
        logger.info(f"‚úÖ [AGENT] Agent processing completed successfully")
        logger.info(f"Response Type: {type(result)}")
        logger.info(f"Response Module: {result.__class__.__module__}")
        return result
        
    except Exception as e:
        logger.error(f"‚ùå [AGENT] Agent processing failed: {str(e)}")
        logger.warning(f"‚ö†Ô∏è [AGENT] Returning fallback result")
        # Return a fallback result if structured output fails
        fallback = AddressResult(
            sido=None,
            sigungu=None,
            road_name=None,
            building_number=None,
            dong=None,
            ho=None,
            legal_dong=None,
            building_name=None,
            confidence={},
            human_review=True  # Always require human review for fallback cases
        )
        return fallback


if __name__ == "__main__":
    extracted_text = "ÏÑúÏö∏Ïãú Í∞ïÎÇ®Íµ¨ ÏûêÍ∑πÎ°ú 21 20Ïù¥Îèô 303 Ìò∏"
    result = extract_and_correct_korean_address(extracted_text)
    print(result)